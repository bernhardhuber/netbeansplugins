<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:rs="http://pmd.sf.net/ruleset/1.0.0">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Ruleset Controversial Rules</title>
<link rel="stylesheet" href="ruleset.css" type="text/css">
<link rel="stylesheet" href="nbdocs:/org/netbeans/modules/usersguide/ide.css" type="text/css">
</head>
<body>
<a name="toc"></a>
<h1>Ruleset Controversial Rules</h1>
<div>
<a href="index.html">Index</a>
</div>
<div>
                    Language -</div>
<h2>Description</h2>
<pre class="rulesetDescription">
The Controversial Ruleset contains rules that, for whatever reason, are considered controversial.  They
are separated out here to allow people to include as they see fit via custom rulesets.  This ruleset was
initially created in response to discussions over UnnecessaryConstructorRule which Tom likes but
most people really dislike :-)
  </pre>
<ul>
<li>
<a href="#UnnecessaryConstructor::">UnnecessaryConstructor::</a>
</li>
<li>
<a href="#NullAssignment::">NullAssignment::</a>
</li>
<li>
<a href="#OnlyOneReturn::">OnlyOneReturn::</a>
</li>
<li>
<a href="#UnusedModifier::">UnusedModifier::</a>
</li>
<li>
<a href="#AssignmentInOperand::">AssignmentInOperand::</a>
</li>
<li>
<a href="#AtLeastOneConstructor::">AtLeastOneConstructor::</a>
</li>
<li>
<a href="#DontImportSun::">DontImportSun::</a>
</li>
<li>
<a href="#SuspiciousOctalEscape::">SuspiciousOctalEscape::</a>
</li>
<li>
<a href="#CallSuperInConstructor::">CallSuperInConstructor::</a>
</li>
<li>
<a href="#UnnecessaryParentheses::">UnnecessaryParentheses::</a>
</li>
<li>
<a href="#SingularField::">SingularField::</a>
</li>
<li>
<a href="#DefaultPackage::">DefaultPackage::</a>
</li>
<li>
<a href="#BooleanInversion::">BooleanInversion::</a>
</li>
<li>
<a href="#DataflowAnomalyAnalysis::">DataflowAnomalyAnalysis::</a>
</li>
</ul>
<a name="UnnecessaryConstructor::"></a>
<h2>Rule UnnecessaryConstructor::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
This rule detects when a constructor is not necessary; i.e., when there's only one constructor,
it's public, has an empty body, and takes no arguments.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Avoid unnecessary constructors - the compiler will generate these for you</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#UnnecessaryConstructor</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public class Foo {
 public Foo() {}
}
  
      </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
            
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
                    
//ClassOrInterfaceBody[count(ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)=1]
/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration
[@Public='true']
[not(FormalParameters/*)]
[not(BlockStatement)]
[not(NameList)]
[count(ExplicitConstructorInvocation/Arguments/ArgumentList/Expression)=0]
                    
                </pre>
</dd>
</dl>
        
<br>
<a href="#toc">TOC</a><a name="NullAssignment::"></a>
<h2>Rule NullAssignment::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
 Assigning a "null" to a variable (outside of its declaration) is usually
 bad form.  Some times, the assignment is an indication that the programmer doesn't
 completely understand what is going on in the code.  NOTE: This sort of assignment
 may in rare cases be useful to encourage garbage collection.  If that's what you're using
 it for, by all means, disregard this rule :-)
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Assigning an Object to null is a code smell. Consider refactoring.</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.design.NullAssignmentRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#NullAssignment</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
 
 public class Foo {
   public void bar() {
     Object x = null; // This is OK.
     x = new Object();
     // Big, complex piece of code here.
     x = null; // This is BAD.
     // Big, complex piece of code here.
   }
 }

 
      </pre>
<br>
<a href="#toc">TOC</a><a name="OnlyOneReturn::"></a>
<h2>Rule OnlyOneReturn::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
A method should have only one exit point, and that should be the last statement in the method.
     </pre>
<dl class="rule">
<dt>Message</dt>
<dd>A method should have only one exit point, and that should be the last statement in the method</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.design.OnlyOneReturnRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#OnlyOneReturn</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
 
 public class OneReturnOnly1 {
  public void foo(int x) {
   if (x &gt; 0) {
    return "hey";   // oops, multiple exit points!
   }
   return "hi";
  }
 }
 
     </pre>
<br>
<a href="#toc">TOC</a><a name="UnusedModifier::"></a>
<h2>Rule UnusedModifier::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
 Fields in interfaces are automatically public static final, and
 methods are public abstract.
 Classes or interfaces nested in an interface are automatically public
 and static (all nested interfaces are automatically static).
 For historical reasons, modifiers which are implied by the context
 are accepted by the compiler, but are superfluous.
     </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Avoid modifiers which are implied by the context</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.UnusedModifier</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#UnusedModifier</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
 
public interface Foo {
 public abstract void bar(); // both abstract and public are ignored by the compiler
 public static final int X = 0; // public, static, and final all ignored
 public static class Bar {} // public, static ignored
 public static interface Baz {} // ditto
}
public class Bar {
 public static interface Baz {} // static ignored
}
 
     </pre>
<br>
<a href="#toc">TOC</a><a name="AssignmentInOperand::"></a>
<h2>Rule AssignmentInOperand::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Avoid assignments in operands; this can make code more complicated and harder to read.
  </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Avoid assignments in operands</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.AssignmentInOperand</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#AssignmentInOperand</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public class Foo {
 public void bar() {
  int x = 2;
  if ((x = getX()) == 3) {
   System.out.println("3!");
  }
 }
 private int getX() {
  return 3;
 }
}
  
  </pre>
<br>
<a href="#toc">TOC</a><a name="AtLeastOneConstructor::"></a>
<h2>Rule AtLeastOneConstructor::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Each class should declare at least one constructor.
  </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Each class should declare at least one constructor</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#AtLeastOneConstructor</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public class Foo {
 // no constructor!  not good!
}
  
  </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
            
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">

//ClassOrInterfaceDeclaration
 [not(ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)]
 [@Interface='false']

                </pre>
</dd>
</dl>
         
<br>
<a href="#toc">TOC</a><a name="DontImportSun::"></a>
<h2>Rule DontImportSun::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Avoid importing anything from the 'sun.*' packages.  These packages are not portable and are likely to change.
       </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Avoid importing anything from the 'sun.*' packages</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.imports.DontImportSun</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#DontImportSun</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>4</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

import sun.misc.foo;
public class Foo {}

       </pre>
<br>
<a href="#toc">TOC</a><a name="SuspiciousOctalEscape::"></a>
<h2>Rule SuspiciousOctalEscape::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
A suspicious octal escape sequence was found inside a String literal.
The Java language specification (section 3.10.6) says an octal
escape sequence inside a literal String shall consist of a backslash
followed by:

   OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

Any octal escape sequence followed by non-octal digits can be confusing,
e.g. "\038" is interpreted as the octal escape sequence "\03" followed by
the literal character "8".
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Suspicious decimal characters following octal escape in string literal</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.SuspiciousOctalEscape</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#SuspiciousOctalEscape</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public class Foo {
 public void foo() {
  // interpreted as octal 12, followed by character '8'
  System.out.println("suspicious: \128");
 }
}

      </pre>
<br>
<a href="#toc">TOC</a><a name="CallSuperInConstructor::"></a>
<h2>Rule CallSuperInConstructor::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
It is a good practice to call super() in a constructor. If super() is not called but
 another constructor (such as an overloaded constructor) is called, this rule will not report it.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>It is a good practice to call super() in a constructor</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#CallSuperInConstructor</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public class Foo extends Bar{
 public Foo() {
  // call the constructor of Bar
  super();
 }
 public Foo(int code) {
  // do something with code
  this();
  // no problem with this
 }
}

      </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
          
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
    
//ClassOrInterfaceDeclaration[ count (ExtendsList/*) &gt; 0 ]
/ClassOrInterfaceBody
 /ClassOrInterfaceBodyDeclaration
 /ConstructorDeclaration[ count (.//ExplicitConstructorInvocation)=0 ]
    
              </pre>
</dd>
</dl>
      
<br>
<a href="#toc">TOC</a><a name="UnnecessaryParentheses::"></a>
<h2>Rule UnnecessaryParentheses::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Sometimes expressions are wrapped in unnecessary parentheses,
making them look like a function call.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>This statement may have some unnecessary parentheses</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#UnnecessaryParentheses</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  public class Foo {
      boolean bar() {
          return (true);
      }
  }
      </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
        
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
                
//ReturnStatement
          /Expression
           /PrimaryExpression
            /PrimaryPrefix
             /Expression[count(*)=1]
              /PrimaryExpression
              /PrimaryPrefix
            </pre>
</dd>
</dl>
    
<br>
<a href="#toc">TOC</a><a name="SingularField::"></a>
<h2>Rule SingularField::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
A field that's only used by one method could perhaps be replaced by a local variable.
          </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Perhaps ''{0}'' could be replaced by a local variable.</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.SingularField</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#SingularField</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public class Foo {
    private int x;
    public void foo(int y) {
     x = y + 5;
     return x;
    }
}

          </pre>
<br>
<a href="#toc">TOC</a><a name="DefaultPackage::"></a>
<h2>Rule DefaultPackage::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Use explicit scoping instead of the default package private level.
        </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Use explicit scoping instead of the default package private level</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#DefaultPackage</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
            
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
//ClassOrInterfaceDeclaration[@Interface='false']
/ClassOrInterfaceBody
/ClassOrInterfaceBodyDeclaration
[
FieldDeclaration[@PackagePrivate='true']
or MethodDeclaration[@PackagePrivate='true']
]
                </pre>
</dd>
</dl>
        
<br>
<a href="#toc">TOC</a><a name="BooleanInversion::"></a>
<h2>Rule BooleanInversion::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Use bitwise inversion to invert boolean values - it's the fastest way to do this.
See http://www.javaspecialists.co.za/archive/newsletter.do?issue=042&amp;locale=en_US for specific details
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Use bitwise inversion to invert boolean values</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/controversial.html#BooleanInversion</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public class Foo {
 public void main(bar) {
  boolean b = true;
  b = !b; // slow
  b ^= true; // fast
 }
}

      </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
          
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
    
//AssignmentOperator[@Image="="]/../Expression/UnaryExpressionNotPlusMinus[@Image="!"]

             </pre>
</dd>
</dl>
      
<br>
<a href="#toc">TOC</a><a name="DataflowAnomalyAnalysis::"></a>
<h2>Rule DataflowAnomalyAnalysis::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">The dataflow analysis tracks local definitions, undefinitions and references to variables on different paths on the data flow.
From those informations there can be found various problems.

1. UR - Anomaly: There is a reference to a variable that was not defined before. This is a bug and leads to an error.
2. DU - Anomaly: A recently defined variable is undefined. These anomalies may appear in normal source text.
3. DD - Anomaly: A recently defined variable is redefined. This is ominous but don't have to be a bug.
          </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Found ''{0}''-anomaly for variable ''{1}'' (lines ''{2}''-''{3}'').</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.dfa.DaaRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>-</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>5</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public class Foo {
    public void foo() {
	 int buz = 5;
	 buz = 6; // redefinition of buz -&gt; dd-anomaly
	 foo(buz);
	 buz = 2; 
    } // buz is undefined when leaving scope -&gt; du-anomaly
}

          </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
            
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">maxviolations</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">100</pre>
</dd>
</dl>
            
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">maxpaths</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">1000</pre>
</dd>
</dl>
          
<br>
<a href="#toc">TOC</a>
</body>
</html>
