<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:rs="http://pmd.sf.net/ruleset/1.0.0">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Ruleset Optimization Rules</title>
<link rel="stylesheet" href="ruleset.css" type="text/css">
<link rel="stylesheet" href="nbdocs:/org/netbeans/modules/usersguide/ide.css" type="text/css">
</head>
<body>
<a name="toc"></a>
<h1>Ruleset Optimization Rules</h1>
<div>
<a href="index.html">Index</a>
</div>
<div>
                    Language -</div>
<h2>Description</h2>
<pre class="rulesetDescription">
These rules deal with different optimizations that generally apply to performance best practices.
  </pre>
<ul>
<li>
<a href="#LocalVariableCouldBeFinal::">LocalVariableCouldBeFinal::</a>
</li>
<li>
<a href="#MethodArgumentCouldBeFinal::">MethodArgumentCouldBeFinal::</a>
</li>
<li>
<a href="#AvoidInstantiatingObjectsInLoops::">AvoidInstantiatingObjectsInLoops::</a>
</li>
<li>
<a href="#UseArrayListInsteadOfVector::">UseArrayListInsteadOfVector::</a>
</li>
<li>
<a href="#SimplifyStartsWith::">SimplifyStartsWith::</a>
</li>
<li>
<a href="#UseStringBufferForStringAppends::">UseStringBufferForStringAppends::</a>
</li>
<li>
<a href="#UseArraysAsList::">UseArraysAsList::</a>
</li>
<li>
<a href="#AvoidArrayLoops::">AvoidArrayLoops::</a>
</li>
<li>
<a href="#UnnecessaryWrapperObjectCreation::">UnnecessaryWrapperObjectCreation::</a>
</li>
</ul>
<a name="LocalVariableCouldBeFinal::"></a>
<h2>Rule LocalVariableCouldBeFinal::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
A local variable assigned only once can be declared final.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Local variable ''{0}'' could be declared final</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.optimization.LocalVariableCouldBeFinal</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#LocalVariableCouldBeFinal</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public class Bar {
 public void foo () {
  String a = "a"; //if a will not be assigned again it is better to do this:
  final String b = "b";
 }
}
  
      </pre>
<br>
<a href="#toc">TOC</a><a name="MethodArgumentCouldBeFinal::"></a>
<h2>Rule MethodArgumentCouldBeFinal::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
A method argument that is never assigned can be declared final.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Parameter ''{0}'' is not assigned and could be declared final</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.optimization.MethodArgumentCouldBeFinal</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#MethodArgumentCouldBeFinal</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public void foo (String param) {
  // do stuff with param never assigning it
  // better: public void foo (final String param) {
}
  
      </pre>
<br>
<a href="#toc">TOC</a><a name="AvoidInstantiatingObjectsInLoops::"></a>
<h2>Rule AvoidInstantiatingObjectsInLoops::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Detects when a new object is created inside a loop
    </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Avoid instantiating new objects inside loops</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.optimization.AvoidInstantiatingObjectsInLoops</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#AvoidInstantiatingObjectsInLoops</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public class Something {
  public static void main( String as[] ) {  
    for (int i = 0; i &lt; 10; i++) {
      Foo f = new Foo(); //Avoid this whenever you can it's really expensive
    }
  }
}

    </pre>
<br>
<a href="#toc">TOC</a><a name="UseArrayListInsteadOfVector::"></a>
<h2>Rule UseArrayListInsteadOfVector::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
ArrayList is a much better Collection implementation than Vector.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Use ArrayList instead of Vector</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#UseArrayListInsteadOfVector</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public class SimpleTest extends TestCase {
 public void testX() {
  Collection c = new Vector();
  // This achieves the same with much better performance
  // Collection c = new ArrayList();
 }
}

          </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
          
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">

//AllocationExpression
 /ClassOrInterfaceType[@Image='Vector' or @Image='java.util.Vector']

              </pre>
</dd>
</dl>
      
<br>
<a href="#toc">TOC</a><a name="SimplifyStartsWith::"></a>
<h2>Rule SimplifyStartsWith::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Since it passes in a literal of length 1, this call to String.startsWith can be rewritten using String.charAt(0) to save some time.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>This call to String.startsWith can be rewritten using String.charAt(0)</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#SimplifyStartsWith</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
  
public class Foo {
  boolean checkIt(String x) {
      return x.startsWith("a");
  }
}

      </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
        
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">

//PrimaryExpression
 [PrimaryPrefix/Name
  [ends-with(@Image, '.startsWith')]]
 [PrimarySuffix/Arguments/ArgumentList
  /Expression/PrimaryExpression/PrimaryPrefix
  /Literal
   [string-length(@Image)=3]
   [starts-with(@Image, '"')]
   [ends-with(@Image, '"')]
 ]
 
            </pre>
</dd>
</dl>
    
<br>
<a href="#toc">TOC</a><a name="UseStringBufferForStringAppends::"></a>
<h2>Rule UseStringBufferForStringAppends::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Finds usages of += for appending strings.
           </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Prefer StringBuffer over += for concatenating strings</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.optimization.UseStringBufferForStringAppends</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#UseStringBufferForStringAppends</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
      
public class Foo {
 void bar() {
  String a;
  a = "foo";
  a += " bar";
  // better would be:
  // StringBuffer a = new StringBuffer("foo");
  // a.append(" bar);
 }
}
      
           </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
          
<br>
<a href="#toc">TOC</a><a name="UseArraysAsList::"></a>
<h2>Rule UseArraysAsList::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
   The class java.util.Arrays has a "asList" method that
   should be use when you want to create a new List from
   an array of objects. It is faster than executing a loop to
   cpy all the elements of the array one by one
     </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Use asList instead of tight loops</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#UseArraysAsList</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
   
   public class Test {
    public void foo(Integer[] ints) {
    // could just use Arrays.asList(ints)
     List l= new ArrayList(10);
     for (int i=0; i&lt; 100; i++) {
      l.add(ints[i]);
     }
     for (int i=0; i&lt; 100; i++) {
      l.add(a[i].toString()); // won't trigger the rule
     }
    }
   }
   
     </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
       
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
   
//Statement[
    (ForStatement) and (count(.//IfStatement)=0)
   ]
   //StatementExpression[
    PrimaryExpression/PrimaryPrefix/Name[
	 substring-before(@Image,'.add') = ancestor::MethodDeclaration//LocalVariableDeclaration[
      ./Type//ClassOrInterfaceType[
       @Image = 'Collection' or 
       @Image = 'List' or @Image='ArrayList'
      ]
     ]
     /VariableDeclarator/VariableDeclaratorId[
      count(..//AllocationExpression/ClassOrInterfaceType[
       @Image="ArrayList"
      ]
      )=1
     ]/@Image
    ]
   and
   PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
   [@Image = ancestor::MethodDeclaration//LocalVariableDeclaration
   [@Array="true"]/VariableDeclarator/VariableDeclaratorId/@Image]
   /../..[count(.//PrimarySuffix)
   =1]/PrimarySuffix/Expression/PrimaryExpression/PrimaryPrefix
   /Name
   ]
   
       </pre>
</dd>
</dl>
     
<br>
<a href="#toc">TOC</a><a name="AvoidArrayLoops::"></a>
<h2>Rule AvoidArrayLoops::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
    Instead of copying data between two arrays, use
    System.arrayCopy method
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>System.arrayCopy is more efficient</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.XPathRule</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#AvoidArrayLoops</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">
    
public class Test {
 public void bar() {
  int[] a = new int[10];
  int[] b = new int[10];
  for (int i=0;i&lt;10;i++) {
   b[i]=a[i];
  }
 }
}
            // this will trigger the rule
            for (int i=0;i&lt;10;i++) {
             b[i]=a[c[i]];
            }

        }
    }
    
      </pre>
<h3>Properties</h3>
<div>Following properties are defined:
            </div>
        
<dl class="property">
<dt>Name</dt>
<dd class="propertyName">xpath</dd>
<dt>Description</dt>
<dd class="propertyDescription">-</dd>
<dt>Value</dt>
<dd>
<pre class="propertyValue">
    
//Statement[(ForStatement or WhileStatement) and
count(*//AssignmentOperator[@Image = '='])=1
and
*/Statement
[
./Block/BlockStatement/Statement/StatementExpression/PrimaryExpression
/PrimaryPrefix/Name/../../PrimarySuffix/Expression
[(PrimaryExpression or AdditiveExpression) and count
(.//PrimaryPrefix/Name)=1]//PrimaryPrefix/Name/@Image
and
./Block/BlockStatement/Statement/StatementExpression/Expression/PrimaryExpression
/PrimaryPrefix/Name/../../PrimarySuffix[count
(..//PrimarySuffix)=1]/Expression[(PrimaryExpression
or AdditiveExpression) and count(.//PrimaryPrefix/Name)=1]
//PrimaryPrefix/Name/@Image
]]
    
        </pre>
</dd>
</dl>
      
<br>
<a href="#toc">TOC</a><a name="UnnecessaryWrapperObjectCreation::"></a>
<h2>Rule UnnecessaryWrapperObjectCreation::</h2>
<a href="#toc">TOC</a>
<h3>Description</h3>
<pre class="ruleDescription">
Parsing method should be called directy instead.
      </pre>
<dl class="rule">
<dt>Message</dt>
<dd>Unnecessary wrapper object creation</dd>
<dt>Class</dt>
<dd>net.sourceforge.pmd.rules.optimization.UnnecessaryWrapperObjectCreation</dd>
<dt>Reference</dt>
<dd>-</dd>
<dt>ExternalInfoUrl</dt>
<dd>http://pmd.sourceforge.net/rules/optimizations.html#UnnecessaryWrapperObjectCreation</dd>
<dt>TypeResolution</dt>
<dd>-</dd>
<dt>Priority</dt>
<dd>3</dd>
</dl>
<h3>Example</h3>
<div>Example code snippet of this rule.
            </div>
<pre class="example">

public int convert(String s) {
  int i, i2;

  i = Integer.valueOf(s).intValue(); // this wastes an object
  i = Integer.parseInt(s); // this is better

  i2 = Integer.valueOf(i).intValue(); // this wastes an object
  i2 = i; // this is better

  return i2;
}

          </pre>
<br>
<a href="#toc">TOC</a>
</body>
</html>
